<!DOCTYPE html>
<meta charset="utf-8">
<title>Rusanivka road graph</title>
<style>

path {
  stroke: #aaa;
  fill: none;
}

circle{
  stroke: none;
}

circle.agent{
  fill: steelblue;
  stroke: none;
}

.link {
  stroke: #000;
  stroke-width: 1.5px;
}

.node {
  cursor: move;
  fill: #ccc;
  stroke: #000;
  stroke-width: 1.5px;
}

.node.fixed {
  fill: #f00;
}

circle.source{
  fill: fuchsia;
  fill-opacity: 0.5;
}

circle.target{
  fill: maroon;
  fill-opacity: 0.3;
}

text{
  font-size: 0.3em;
  font-family: Arial;
  fill: #888;
}

path.walk{
  stroke: dodgerblue;
  stroke-width: 0.1px;
  stroke-opacity: 0.2;
  fill: none;
}

path.way{
  stroke: #bebebe;
  stroke-width: 0.5px;
  stroke-opacity: 0.9;
  fill: none;
}

</style>
<svg width="1900" height="1200"></svg>
<script src="d3.min.js"></script>
<script src="normal.js"></script>
<script>
var width = 1900, height = 1200;
var graph;

var projection = d3.geo.mercator()
        .center([30.597, 50.439]) 
        .scale(3000000)
        .translate([width / 2, height / 2]);


var path = d3.geo.path()
    .projection(projection);

var svg = d3.select("svg");

d3.json("streets.json", function(error, collection) {
  if (error) throw error;


  svg.selectAll("path") // roads
      .data(collection.features)
    .enter().append("path")
      .attr("class", 'way')
      .attr("d", path);

  var circles = svg.selectAll('circle')
  	.data(collection.features)
  	.enter();

  circles // from nodes	
  	.append('circle')
    .attr('class', 'source')
  	.attr('cx', function(d){return projection( [d.properties.x1, d.properties.y1] )[0] })
  	.attr('cy', function(d){return projection([d.properties.x1, d.properties.y1])[1] })
  	.attr('r', 2)
    .attr('id', function(d){return 'c' + d.properties.source} )
  	


  circles // to nodes	
  	.append('circle')
    .attr('class', 'target')
  	.attr('cx', function(d){return projection( [d.properties.x2, d.properties.y2] )[0] })
  	.attr('cy', function(d){return projection([d.properties.x2, d.properties.y2])[1] })
  	.attr('r', 2)
    .attr('id', function(d){return 'c' + d.properties.target} )
  	//.style('fill', 'red')


   circles
    .append("text")

    .attr("x", function(d){return projection( [d.properties.x1, d.properties.y1] )[0] })
    .attr("y", function(d){return projection([d.properties.x1, d.properties.y1])[1] })
    .attr("dx", 3)
    .attr("dy", -2)
    .text(function(d) { return d.properties.source; });


  // make a graph in adj. list form
  // 1. switch source and target
    var gdata = collection.features.map(function(r){
        var rez = {}, coo1 = projection( [r.properties.x1, r.properties.y1] ), coo2 = projection( [r.properties.x2, r.properties.y2] );
        rez.x1 = ~~coo1[0];
        rez.y1 = ~~coo1[1];
        rez.x2 = ~~coo2[0];
        rez.y2 = ~~coo2[1];
        rez.source = r.properties.source;
        rez.target = r.properties.target;
        rez.geom = r.geometry.coordinates.map(function(pair){ return (projection(pair)).map(function(d){return ~~d;})  ; });
        return rez;

    })

    // create mirrowed version of gdata, to add bi-directional links to graph
    gdata = gdata.concat(     
        gdata.map(function(d){
          var rez = {}; rez.x1 = d.x2; rez.x2 = d.x1; rez.y2 = d.y1; rez.y1 = d.y2;  
          rez.target = d.source; rez.source = d.target;
          var geom = d.geom.slice(0); // copy that
          geom.reverse();
          rez.geom = geom;
          return rez;
        })
    )

    var graph_adj = d3.nest()  // graph in form of adjacement list 
      .key(function(d){return d.source;})
      .map(gdata);

    graph = graph_adj;
  //console.log( graph_adj );
    

    
    
    // simulation ...
    for(var t = 0; t < 500; t++){
          // our first agent 
        // generate initial node  464, 122, 130, 173, 250
        var agent1 = new Agent(graph_adj[130][0]);
        agent1.add_to_map(svg);
        agent1.line(svg);
        
        var agent2 = new Agent(graph_adj[122][0]);
        agent2.add_to_map(svg);
        agent2.line(svg);
        
        var agent3 = new Agent(graph_adj[250][0]);
        agent3.add_to_map(svg);
        agent3.line(svg);

        [agent1, agent2, agent3].forEach(function(a){
          update_node_count(a.path, nodes);
        })



    }
console.log(d3.selectAll('path.walk')[0].length)
console.log(nodes);
});

function update_node_count(path, nodes){
  path.forEach(function(n){
    nodes[n] = typeof nodes[n] === 'undefined' ? 1 : ++nodes[n];//count node crossing 
    //return nodes;
  })
}


function get_random(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function mode(array){
  var frequency = {};  // array of frequency.
  var max = 0;  // holds the max frequency.
  var result;   // holds the max frequency element.
  for(var v in array) {
        frequency[array[v]]=(frequency[array[v]] || 0)+1; // increment frequency.
        if(frequency[array[v]] > max) { // is this frequency > max so far ?
                max = frequency[array[v]];  // update max.
                result = array[v];          // update result.
        }
  }
  return result;
}

function path_shortener(array){
  var champ = mode(array);
//console.log(champ)  
  var last = array.lastIndexOf(champ);
  var first = array.indexOf(champ);
  array.splice(first, last - first);
  return array;
}

var stddev = 20;
var line_fun = d3.svg.line()
  .x(function(d) { return d[0] + normalRandomScaled(0, stddev); }) // add jitter to lines
  .y(function(d) { return d[1] + normalRandomScaled(0, stddev); })
  .interpolate("linear");

var nodes = {};
var Agent = (function() {
        var id = 0;  // class type var
   
        function nextid() { return id++; }

        function angle(n){  return Math.atan2(n.y2 - n.y1, n.x2 - n.x1); }

        function create_path(agent){
          var current_node = agent.node, path = [current_node], next_node_obj;
          while(path.length < 50){
            //nodes[current_node] = typeof nodes[current_node] === 'undefined' ? 1 : ++nodes[current_node];//count node crossing 

            var closest_nodes = graph[current_node]; // neighbours 
            // avoid a trap
            if( closest_nodes.length === 1){ var n =  graph[current_node][0].target; path.push(n); current_node = n; continue; }
            // we prefer directions closer to 180 degree
            var to_east = graph[current_node].filter(function(n){ return Math.abs( angle( n ) ) > 3.14159/2.5 }); 
            if(to_east.length > 0 ){
              to_east.sort(function(a, b){return Math.abs( angle( b ) ) - Math.abs( angle( a ) ) });
              if( Math.random() < 0.5 ){ // choose best of 'eastern' directions
                next_node_obj = to_east[0]; 
              } else { // choose any of them
                next_node_obj = to_east[ get_random(0, to_east.length - 1) ];  
              }
            } else { // choose any of non-eastern dirs
              next_node_obj = closest_nodes[ get_random(0, closest_nodes.length - 1) ];
            }  
              path.push(next_node_obj.target);
              current_node = next_node_obj.target;
              
              

          } 
          return path;
        }

        var Agent = function(node) {
          this.id = nextid();
          this.node = node.source;
          this.x = node.x1;
          this.y = node.y1;
          this.path = path_shortener( path_shortener( create_path(this) )); //nodes

          this.way = this.path.reduce(function(acum, current, index, array){ // line fragments
               var lines;
              if(array[index + 1]){
                lines = graph[current].filter(function(d){ return d.source === current && d.target === array[index + 1] })[0].geom; 
                lines = lines.slice(0, lines.length - 1);     
              } else {
                var boo = graph[current];
                lines = [[boo.x1, boo.y1]];
              }
              return acum.concat( lines );
          }, []);


//console.log( this.way );

          this.speed = 1;

        };

        Agent.prototype = {
          clear_from_map: function(sel){  sel.select('circle#a' + this.id ).remove(); },
          add_to_map: function(sel){ 
            sel
              .append('circle')
              .attr('id', 'a'+this.id)
              .attr('class', 'agent')
              .attr('r', '4')
              .attr('cx', this.x)
              .attr('cy', this.y);
          },
          line: function(sel){
            sel.append("path")
              .attr('class', 'walk')
              .attr("d", line_fun(this.way))
             
          },
          position: function(t){}, // position at time t ,
          nodes_since: function (time){
  
          },
          //angle: function(n2){  return angle(this, n2); },
          length: function(n2){ return Math.sqrt((this.x - n2.x)*(this.x - n2.x) + (this.y - n2.y)*(this.y - n2.y)) }
        };

        return Agent;
})();





</script>
