<!DOCTYPE html>
<meta charset="utf-8">
<title>Rusanivka road graph</title>
<style>

path {
  stroke: #ddd;
  fill: none;
}

circle{
  stroke: none;
}

circle.agent{
  fill: steelblue;
  stroke: none;
}

.link {
  stroke: #000;
  stroke-width: 1.5px;
}

.node {
  cursor: move;
  fill: #ccc;
  stroke: #000;
  stroke-width: 1.5px;
}

.node.fixed {
  fill: #f00;
}

text{
  font-size: 0.3em;
  font-family: Arial;
  fill: #bbb;
}

path.walk{
  stroke: orange;
  stroke-width: 2px;
  stroke-opacity: 0.5;
  fill: none;
}

</style>
<svg width="1900" height="1200"></svg>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>
var width = 1900, height = 1200;
var graph;

var projection = d3.geo.mercator()
        .center([30.597, 50.439]) 
        .scale(3000000)
        .translate([width / 2, height / 2]);


var path = d3.geo.path()
    .projection(projection);

var svg = d3.select("svg");

d3.json("streets.json", function(error, collection) {
  if (error) throw error;


  svg.selectAll("path") // roads
      .data(collection.features)
    .enter().append("path")
      .attr("d", path);

  var circles = svg.selectAll('circle')
  	.data(collection.features)
  	.enter();

  circles // from nodes	
  	.append('circle')
  	.attr('cx', function(d){return projection( [d.properties.x1, d.properties.y1] )[0] })
  	.attr('cy', function(d){return projection([d.properties.x1, d.properties.y1])[1] })
  	.attr('r', 2)
    .attr('id', function(d){return 'c' + d.properties.source} )
  	.style('fill', 'navyblue')


  circles // to nodes	
  	.append('circle')
  	.attr('cx', function(d){return projection( [d.properties.x2, d.properties.y2] )[0] })
  	.attr('cy', function(d){return projection([d.properties.x2, d.properties.y2])[1] })
  	.attr('r', 2)
    .attr('id', function(d){return 'c' + d.properties.target} )
  	.style('fill', 'red')


   circles
    .append("text")

    .attr("x", function(d){return projection( [d.properties.x1, d.properties.y1] )[0] })
    .attr("y", function(d){return projection([d.properties.x1, d.properties.y1])[1] })
    .attr("dx", 3)
    .attr("dy", -2)
    .text(function(d) { return d.properties.source; });

/*
  // make a graph in d3 form
    var graph_d3 = {nodes: [], links: []};
    collection.features.forEach(function(r){
        var is = +r.properties.source - 1; 
        var it = +r.properties.target - 1; 
        graph_d3.links.push({source: is, target: it})
        graph_d3.nodes[is] = {x:  projection( [r.properties.x1, r.properties.y1] )[0], y: projection( [r.properties.x1, r.properties.y1] )[1]}
        graph_d3.nodes[it] = {x: projection( [r.properties.x2, r.properties.y2] )[0], y: projection( [r.properties.x2, r.properties.y2] )[1]}
    })
*/

  // make a graph in adj. list form
  // 1. switch source and target
    var gdata = collection.features.map(function(r){
        var rez = {}, coo1 = projection( [r.properties.x1, r.properties.y1] ), coo2 = projection( [r.properties.x2, r.properties.y2] );
        rez.x1 = ~~coo1[0];
        rez.y1 = ~~coo1[1];
        rez.x2 = ~~coo2[0];
        rez.y2 = ~~coo2[1];
        rez.source = r.properties.source;
        rez.target = r.properties.target;
        rez.geom = r.geometry.coordinates.map(function(pair){ return (projection(pair)).map(function(d){return ~~d;})  ; });
        return rez;

    })

    // create mirrowed version of gdata, to add bi-directional links to graph
    gdata = gdata.concat(     
        gdata.map(function(d){
          var rez = {}; rez.x1 = d.x2; rez.x2 = d.x1; rez.y2 = d.y1; rez.y1 = d.y2;  
          rez.target = d.source; rez.source = d.target;
          var geom = d.geom.slice(0);
          geom.reverse();
          rez.geom = geom;
          return rez;
        })
    )

    var graph_adj = d3.nest()
      .key(function(d){return d.source;})
      .map(gdata);

    graph = graph_adj;
  //console.log( graph_adj );
    

    // our first agent 
    // generate initial node
    var agent = new Agent(graph_adj[122][0]);
    agent.add_to_map(svg);
    agent.line(svg);
    // generate path
    //agent.create_path();
    
    // return coordinates in time t
    for(var t = 0; t < 1000; t++){
//      agent.move(t);
    }

});

function get_random(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function mode(array){
  var frequency = {};  // array of frequency.
  var max = 0;  // holds the max frequency.
  var result;   // holds the max frequency element.
  for(var v in array) {
        frequency[array[v]]=(frequency[array[v]] || 0)+1; // increment frequency.
        if(frequency[array[v]] > max) { // is this frequency > max so far ?
                max = frequency[array[v]];  // update max.
                result = array[v];          // update result.
        }
  }
  return result;
}

function path_shortener(array){
  var champ = mode(array);
//console.log(champ)  
  var last = array.lastIndexOf(champ);
  var first = array.indexOf(champ);
  array.splice(first, last - first);
  return array;
}

var line_fun = d3.svg.line()
  .x(function(d) { return d[0]; })
  .y(function(d) { return d[1]; })
  .interpolate("linear");


var Agent = (function() {
        var id = 0;  // class type var
   
        function nextid() { return id++; }

        function angle(n){  return Math.atan2(n.y2 - n.y1, n.x2 - n.x1); }

        function create_path(agent){
          var current_node = agent.node, path = [current_node], next_node_obj;
          while(path.length < 100){
            //console.log(graph[current_node]);
            var closest_nodes = graph[current_node];
            if( closest_nodes.length === 1){ var n =  graph[current_node][0].target; path.push(n); current_node = n; continue; }
            //console.log(closest_nodes);
            //console.log(graph[current_node]);
              var to_east = graph[current_node].filter(function(n){ return Math.abs( angle( n ) ) > 3.14159/2.5 }); // 
            //console.log(to_east);
              if(to_east.length > 0 ){
                next_node_obj = to_east[ get_random(0, to_east.length - 1) ];
              } else {
                next_node_obj = closest_nodes[ get_random(0, closest_nodes.length) ];
              }  
        //console.log(next_node_obj)
              path.push(next_node_obj.target);
              current_node = next_node_obj.target;
          } 

          return path;

        }

        var Agent = function(node) {
          this.id = nextid();
          this.node = node.source;
          this.x = node.x1;
          this.y = node.y1;
          this.path = path_shortener( path_shortener( create_path(this) ));
//console.log( this.path );

          this.way = this.path.reduce(function(acum, current, index, array){
               var lines;
              if(array[index + 1]){
                lines = graph[current].filter(function(d){ return d.source === current && d.target === array[index + 1] })[0].geom; 
                lines = lines.slice(0, lines.length - 1);     
              } else {
                var boo = graph[current];
                lines = [[boo.x1, boo.y1]];
              }
              return acum.concat( lines );
          }, []);


//console.log( this.way );

          this.speed = 1;

        };

        Agent.prototype = {
          clear_from_map: function(sel){  sel.select('circle#a' + this.id ).remove(); },
          add_to_map: function(sel){ 
            sel
              .append('circle')
              .attr('id', 'a'+this.id)
              .attr('class', 'agent')
              .attr('r', '4')
              .attr('cx', this.x)
              .attr('cy', this.y);
          },
          line: function(sel){
            sel.append("path")
              .attr('class', 'walk')
              .attr("d", line_fun(this.way))
             
          },
          //angle: function(n2){  return angle(this, n2); },
          length: function(n2){ return Math.sqrt((this.x - n2.x)*(this.x - n2.x) + (this.y - n2.y)*(this.y - n2.y)) }
        };

        return Agent;
})();





</script>
